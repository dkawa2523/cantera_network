# NetBench: centrality-based reduction sweep (multiple top_k) + validation
steps:
  - id: sim
    task: sim.run_csv
    sim: ${sim}
    params:
      conditions_file: ${benchmarks.conditions_file}
      case_id: ${benchmarks.case_id}

  - id: graph_mech
    task: graphs.stoich
    graphs:
      mechanism: ${mechanism.path}
    params: {}

  - id: graph_flux
    task: graphs.temporal_flux
    inputs:
      run_id: "@sim"
      mechanism: ${mechanism.path}
    params: {}

  - id: features
    task: features.run
    inputs: { run_id: "@sim", graph: "@graph_mech" }
    params:
      cache_bust: "2026-02-08"
      features:
        - name: network_metrics
          params:
            metrics: [betweenness]
            node_kinds: [reaction]
            top_n: 400
            betweenness_max_nodes: 1500

  # Sweep: order from larger->smaller keeps so that selected_patch becomes
  # "most aggressive passing" patch (since later failures won't overwrite it).
  - id: red_k250
    task: reduction.threshold_prune
    inputs:
      features: "@features"
    importance:
      column: value
      mode: abs
      aggregate: max
    threshold:
      top_k: 250

  - id: red_k200
    task: reduction.threshold_prune
    inputs:
      features: "@features"
    importance:
      column: value
      mode: abs
      aggregate: max
    threshold:
      top_k: 200

  - id: red_k150
    task: reduction.threshold_prune
    inputs:
      features: "@features"
    importance:
      column: value
      mode: abs
      aggregate: max
    threshold:
      top_k: 150

  - id: red_k120
    task: reduction.threshold_prune
    inputs:
      features: "@features"
    importance:
      column: value
      mode: abs
      aggregate: max
    threshold:
      top_k: 120

  - id: red_k100
    task: reduction.threshold_prune
    inputs:
      features: "@features"
    importance:
      column: value
      mode: abs
      aggregate: max
    threshold:
      top_k: 100

  - id: red_k80
    task: reduction.threshold_prune
    inputs:
      features: "@features"
    importance:
      column: value
      mode: abs
      aggregate: max
    threshold:
      top_k: 80

  - id: red_k60
    task: reduction.threshold_prune
    inputs:
      features: "@features"
    importance:
      column: value
      mode: abs
      aggregate: max
    threshold:
      top_k: 60

  - id: red_k50
    task: reduction.threshold_prune
    inputs:
      features: "@features"
    importance:
      column: value
      mode: abs
      aggregate: max
    threshold:
      top_k: 50

  - id: validation
    task: reduction.validate
    inputs:
      patches:
        - "@red_k250"
        - "@red_k200"
        - "@red_k150"
        - "@red_k120"
        - "@red_k100"
        - "@red_k80"
        - "@red_k60"
        - "@red_k50"
    mechanism: ${mechanism.path}
    validation:
      pipeline: bench_gri30_netbench_validation
      case_mode: all
      # Default is val-set; override via benchmarks.validation_conditions_file when needed.
      conditions_file: ${oc.select:benchmarks.validation_conditions_file,benchmarks/assets/conditions/gri30_netbench_val.csv}
      metric: rel
      tolerance: 0.5
      stop_on_fail: false
      use_multipliers_only: true
      sim_step_id: sim
      observables_step_id: observables
      features_step_id: features

  - id: viz
    task: viz.benchmark_report
    name: bench_gri30_netbench_reduce_centrality_sweep
    dashboard: benchmark
    chart_backend: svg
    export_images:
      enabled: true
      formats: [svg]
      dir: images
    inputs:
      runs: "@sim"
      graphs: ["@graph_mech", "@graph_flux"]
      reduction:
        - "@red_k250"
        - "@red_k200"
        - "@red_k150"
        - "@red_k120"
        - "@red_k100"
        - "@red_k80"
        - "@red_k60"
        - "@red_k50"
      validation:
        - "@validation"
    graphviz:
      top_n: 8
      max_nodes: 80
      max_edges: 160
      engine: dot
    reduction_effect:
      top_n: 12
    params: {}

